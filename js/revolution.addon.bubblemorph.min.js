/* 
 * @author    ThemePunch <info@themepunch.com>
 * @link      http://www.themepunch.com/
 * @copyright 2018 ThemePunch
 */

! function() { "use strict"; var A, C;

    function O() { var t = A(this),
            e = t.data("bubbleaddon");
        e && (e.destroy(), t.removeData("bubbleaddon")) }

    function P(t, e) { if (!t) return !1; if (0 === e) return t[e]; for (var i = e, s = t[e];
            "inherit" === s;) s = -1 < --i ? t[i] : t[0]; return s }

    function s() { var t = A(this),
            e = t.data("bubbleObj"),
            i = !1; if (e && (9999 === e.slideIndex && parseInt(t.data("bubbleIndex"), 0) >= parseInt(t.data("startslide"), 0) && parseInt(t.data("bubbleIndex"), 0) <= parseInt(t.data("endslide"), 0) && (i = !0), t.data("bubbleIndex") == e.slideIndex || !0 === i)) { t.data("bubbleaddon") && O.call(this); var s, r, h, a = e.levels,
                n = a.length,
                l = C.width(),
                o = 0; if (a)
                for (var d = 0; d < n; d++) r !== (h = a[d]) && (l < h && (o = d), r = h); var u = e.layerW[o],
                c = e.layerH[o],
                p = "100%" === c || "full" === c; if ("100%" === u || "full" === u) { var b = !e.carousel || e.isStatic ? e.slider : e.slotholder;
                e.fullAlign ? (u = b.width(), e.wrapper[0].style.left = 0) : (s = Math.min(e.slider.width() / e.grids[o], 1), u = e.grids[o] * s) } else u = parseInt(e.layr.css("width"), 10);
            p ? (c = e.isStatic ? e.slider.height() : e.slotholder.height(), e.wrapper[0].style.top = 0) : c = parseInt(e.layr.css("height"), 10); var f = P(e.blurStrength, o),
                g = P(e.borderSize, o),
                y = P(e.borderColor, o),
                v = P(e.blurColor, o),
                m = P(e.blurX, o),
                x = P(e.blurY, o),
                w = P(e.bufferX, o),
                M = P(e.bufferY, o),
                I = P(e.numBubbles, o),
                F = P(e.velX, o),
                z = P(e.velY, o),
                S = function(e, i, t, s, r, h, a, n, l, o, d, u, c, p, b, f) { var g, y = { screen: { elem: null, callback: null, ctx: null, width: 0, height: 0, left: 0, top: 0, init: function(t, e) { return this.elem = s, this.callback = t || null, "CANVAS" == this.elem.tagName && (this.ctx = this.elem.getContext("2d")), this.elem.onselectstart = function() { return !1 }, this.elem.ondrag = function() { return !1 }, e && this.resize(), this }, resize: function() { var t = this.elem; for (this.width = e, this.height = i, this.left = 0, this.top = 0; null != t; t = t.offsetParent) this.left += t.offsetLeft, this.top += t.offsetTop;
                                    this.ctx && (this.elem.width = this.width, this.elem.height = this.height), g && (g.width = this.width, g.height = this.height), this.callback && this.callback() }, destroy: function() { for (var t in this) this.hasOwnProperty(t) && delete this[t] } } },
                        v = function(t, e) { this.x = t, this.y = e, this.magnitude = t * t + e * e, this.computed = 0, this.force = 0 };
                    v.prototype.add = function(t) { return new v(this.x + t.x, this.y + t.y) }; var m = function(t) { this.vel = new v((.5 < Math.random() ? 1 : -1) * (.2 + Math.random() * b), (.5 < Math.random() ? 1 : -1) * (.2 + Math.random() * f)), this.pos = new v(.2 * t.width + Math.random() * t.width * .6, .2 * t.height + Math.random() * t.height * .6), this.size = t.wh / 15 + (1.4 * Math.random() + .1) * (t.wh / 15), this.width = t.width, this.height = t.height };
                    m.prototype.move = function() { this.pos.x >= this.width - this.size - c ? (0 < this.vel.x && (this.vel.x = -this.vel.x), this.pos.x = this.width - this.size - c) : this.pos.x <= this.size + c && (this.vel.x < 0 && (this.vel.x = -this.vel.x), this.pos.x = this.size + c), this.pos.y >= this.height - this.size - p ? (0 < this.vel.y && (this.vel.y = -this.vel.y), this.pos.y = this.height - this.size - p) : this.pos.y <= this.size + p && (this.vel.y < 0 && (this.vel.y = -this.vel.y), this.pos.y = this.size + p), this.pos = this.pos.add(this.vel) }; var x = function(t, e, i, s) { this.step = 5, this.width = t, this.height = e, this.wh = Math.min(t, e), this.sx = Math.floor(this.width / this.step), this.sy = Math.floor(this.height / this.step), this.paint = !1, this.metaFill = w(t, e, s), this.plx = [0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0], this.ply = [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1], this.mscases = [0, 3, 0, 3, 1, 3, 0, 3, 2, 2, 0, 2, 1, 1, 0], this.ix = [1, 0, -1, 0, 0, 1, 0, -1, -1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1], this.grid = [], this.balls = [], this.iter = 0, this.sign = 1; for (var r = 0; r < (this.sx + 2) * (this.sy + 2); r++) this.grid[r] = new v(r % (this.sx + 2) * this.step, Math.floor(r / (this.sx + 2)) * this.step); for (var h = 0; h < i; h++) this.balls[h] = new m(this) };
                    x.prototype.destroy = function() { var t; for (t in this.balls) this.balls.hasOwnProperty(t) && delete this.balls[t]; for (t in this) this.hasOwnProperty(t) && delete this[t] }, x.prototype.computeForce = function(t, e, i) { var s, r = i || t + e * (this.sx + 2); if (0 === t || 0 === e || t === this.sx || e === this.sy) s = .6 * this.sign;
                        else { s = 0; var h = this.grid[r]; if (!h) return; for (var a, n = 0; a = this.balls[n++];) s += a.size * a.size / (-2 * h.x * a.pos.x - 2 * h.y * a.pos.y + a.pos.magnitude + h.magnitude);
                            s *= this.sign } if (this.grid[r]) return this.grid[r].force = s }, x.prototype.marchingSquares = function(t) { var e = t[0],
                            i = t[1],
                            s = t[2],
                            r = e + i * (this.sx + 2); if (this.grid[r]) { if (this.grid[r].computed === this.iter) return !1; for (var h, a, n = 0, l = 0; l < 4; l++) { var o = e + this.ix[l + 12] + (i + this.ix[l + 16]) * (this.sx + 2); if (!this.grid[o]) { a = !0; break } var d = this.grid[o].force;
                                (0 < d && this.sign < 0 || d < 0 && 0 < this.sign || !d) && (d = this.computeForce(e + this.ix[l + 12], i + this.ix[l + 16], o)), 1 < Math.abs(d) && (n += Math.pow(2, l)) } if (!a) { if (15 === n) return [e, i - 1, !1]; if (5 === n) h = 2 === s ? 3 : 1;
                                else if (10 === n) h = 3 === s ? 0 : 2;
                                else { if (h = this.mscases[n], !this.grid[r]) return;
                                    this.grid[r].computed = this.iter } var u = this.step / (Math.abs(Math.abs(this.grid[e + this.plx[4 * h + 2] + (i + this.ply[4 * h + 2]) * (this.sx + 2)].force) - 1) / Math.abs(Math.abs(this.grid[e + this.plx[4 * h + 3] + (i + this.ply[4 * h + 3]) * (this.sx + 2)].force) - 1) + 1); return F.lineTo(this.grid[e + this.plx[4 * h] + (i + this.ply[4 * h]) * (this.sx + 2)].x + this.ix[h] * u, this.grid[e + this.plx[4 * h + 1] + (i + this.ply[4 * h + 1]) * (this.sx + 2)].y + this.ix[h + 4] * u), this.paint = !0, [e + this.ix[h + 4], i + this.ix[h + 8], h] } } }, x.prototype.renderMetaballs = function() { for (var t, e = 0; t = this.balls[e++];) t.move(); for (this.iter++, this.sign = -this.sign, this.paint = !1, F.fillStyle = this.metaFill, a && (F.shadowBlur = a, F.shadowColor = n, F.shadowOffsetX = l, F.shadowOffsetY = o), u && (F.strokeStyle = d, F.lineWidth = u), F.beginPath(), e = 0; t = this.balls[e++];) { for (var i = [Math.round(t.pos.x / this.step), Math.round(t.pos.y / this.step), !1]; i = this.marchingSquares(i););
                            this.paint && (F.fill(), F.closePath(), u && F.stroke(), F.beginPath(), this.paint = !1) } }; var w = function(t, e, i) { return i[1] ? "radial" === (i = i[0]).type ? function(t, e, i, s) { e *= .5, i *= .5; for (var r, h = t.createRadialGradient(e, i, 0, e, i, e), a = s.length, n = 0; n < a; n++) r = s[n], h.addColorStop(.01 * r.position, B(r.r, r.g, r.b, r.a)); return h }(F, t, e, i.colors) : function(t, e, i, s, r) { var h, a = 0,
                                    n = 0,
                                    l = 0,
                                    o = 0; if (r = parseInt(r, 10), /0|90|180|270|360/.test(r)) switch (r) {
                                    case 0:
                                    case 360:
                                        n = i; break;
                                    case 90:
                                        l = e; break;
                                    case 180:
                                        o = i; break;
                                    case 270:
                                        a = e } else { e *= .5, i *= .5; var d = (r - 180) * (Math.PI / 180),
                                        u = i / Math.cos(d),
                                        c = e - Math.sqrt(u * u - i * i),
                                        p = Math.sin(d) * c;
                                    h = u + p, a = e + Math.cos(-Math.PI / 2 + d) * h, n = i + Math.sin(-Math.PI / 2 + d) * h, l = e + Math.cos(Math.PI / 2 + d) * h, o = i + Math.sin(Math.PI / 2 + d) * h }
                                var b, f, g = t.createLinearGradient(Math.round(a), Math.round(n), Math.round(l), Math.round(o));
                                h = s.length; for (var y = 0; y < h; y++) b = s[y], f = parseInt(b.position, 10), g.addColorStop(.01 * f, B(b.r, b.g, b.b, b.a)); return g }(F, t, e, i.colors, i.angle) : i[0] },
                        M = function() { S && !S.pause && (F.clearRect(0, 0, I.width, I.height), g.renderMetaballs(), requestAnimationFrame(M)) },
                        I = y.screen.init(null, !0),
                        F = I.ctx,
                        z = function() { g = new x(I.width, I.height, r, h) }; var S = { play: M, pause: !1, screen: I, inited: z, started: !1, destroy: function() { S.pause = !0, cancelAnimationFrame(M), F.clearRect(0, 0, I.width, I.height), g && g.destroy(), I.destroy(), F = w = z = S = I = M = x = m = v = y = g = null } }; return S }(u, c, e.slider, e.canvas, parseInt(I, 10), e.color, parseInt(f, 10), v, parseInt(m, 10), parseInt(x, 10), y, parseInt(g, 10), parseInt(w, 10), parseInt(M, 10), parseFloat(F), parseFloat(z));
            t.data("bubbleaddon", S), t.data("bubblesplaying") && k(S, t) } }

    function k(t, e) { t.pause = !1, t.screen.resize(), t.started || (t.started = !0, t.inited()), e.data("bubblesplaying", !0), t.play() }

    function r(t, e) { this.slider = t, this.carousel = e, t.one("revolution.slide.onloaded", this.onLoaded.bind(this)).one("rsBubbleMorphDestroyed", this.destroy.bind(this)) }

    function w(t) { for (var e, i = t.colors, s = i.length, r = [], h = 0; h < s; h++) { var a = i[h];
            delete a.align, e ? JSON.stringify(a) !== JSON.stringify(e) && (r[r.length] = a) : r[r.length] = a, e = a } return t.colors = r, t }

    function B(t, e, i, s) { return "rgba(" + t + ", " + e + ", " + i + ", " + s + ")" }
    window.BubbleMorphAddOn = function(t, e, i) { if (t && e) return C = (A = t)(window), A.event.special.rsBubbleMorphDestroyed = { remove: function(t) { t.handler() } }, new r(e, i) }, r.prototype = { onLoaded: function() { var t, y = this.slider,
                v = this.carousel,
                e = !(!A.fn.revolution || !A.fn.revolution[y[0].id]) && A.fn.revolution[y[0].id]; if (e) { var m = e.gridwidth,
                    x = e.responsiveLevels; for (Array.isArray(m) || (m = [m]); m.length < 4;) m[m.length] = m[m.length - 1]; for (t = 0; t < 4; t++) m[t] = parseInt(m[t], 10); if (x) { for (Array.isArray(x) || (x = [x]); x.length < 4;) x[x.length] = x[x.length - 1]; for (t = 0; t < 4; t++) x[t] = parseInt(x[t], 10) }
                this.morph = y.find(".tp-bubblemorph").each(function() { var t = A(this),
                        e = t.attr("data-bubblemorph"); try { e = JSON.parse(e) } catch (t) { return } var i = A("<canvas />").appendTo(t),
                        s = e.num,
                        r = e.speedx,
                        h = e.speedy,
                        a = e.bufferx,
                        n = e.buffery,
                        l = t.attr("data-dim"); if (l) { for (var o = !1, d = !1, u = (l = l.split(";")).length, c = 0; c < u && ("w" === l[c].charAt(0).toLowerCase() ? o = l[c].replace("w:", "").split(",") : "h" === l[c].charAt(0).toLowerCase() && (d = l[c].replace("h:", "").split(",")), !1 === o || !1 === d); c++); if (!1 !== o && !1 !== d) { for (; o.length < 4;) o[o.length] = o[o.length - 1]; for (; d.length < 4;) d[d.length] = d[d.length - 1]; for (; d.length < o.length;) d[d.length] = d[d.length - 1]; for (; o.length < d.length;) d[o.length] = o[o.length - 1];
                            s = s.split("|"), a = a.split("|"), n = n.split("|"), r = r.split("|"), h = h.split("|"); var p = t.hasClass("rs-layer-static") ? t.closest("rs-static-layers") : t.closest("rs-slide"); var b = { velX: r, velY: h, layr: t, grids: m, layerW: o, layerH: d, slider: y, levels: x, bufferX: a, bufferY: n, canvas: i[0], carousel: v, numBubbles: s, wrapper: t.closest("rs-layer-wrap"), isStatic: t.hasClass("rs-layer-static"), color: function(t) { if ("object" == typeof t) return [t = w(t), !0]; { if ("transparent" === t.trim()) return ["#FFFFFF", !1]; if (-1 === t.search(/\[\{/)) return -1 !== t.search("#") ? [t, !1] : -1 !== t.search("rgba") ? [t.replace(/\s/g, "").replace(/false/g, "1"), !1] : -1 !== t.search("rgb") ? [t.replace(/\s/g, ""), !1] : /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t) ? [t, !1] : ["#FFFFFF", !1]; try { return [t = w(t = JSON.parse(t.replace(/\&/g, '"'))), !0] } catch (t) { return ["#FFFFFF", !1] } } }(e.bg), fullAlign: "slide" === this.getAttribute("data-basealign"), slotholder: p.find("rs-sbg-wrap"), slideIndex: t.hasClass("rs-layer-static") ? 9999 : parseInt(p.attr("data-originalindex"), 10) },
                                f = e.blur;
                            f && (b.blurStrength = f.split("|"), b.blurColor = e.blurcolor.split("|"), b.blurX = e.blurx.split("|"), b.blurY = e.blury.split("|")); var g = e.bordersize;
                            g && (b.borderSize = g.split("|"), b.borderColor = e.bordercolor.split("|")), t.data("bubbleObj", b) } } }), this.morph.length ? y.on("revolution.slide.onbeforeswap", this.beforeChange.bind(this)).on("revolution.slide.afterdraw", this.onResize.bind(this)).on("revolution.slide.layeraction", this.layerAction.bind(this)) : this.destroy() } }, beforeChange: function(t, e) { this.slider.find(".tp-bubblemorph").data("bubbleIndex", parseInt(e.nextSlideIndex, 10)) }, createBubbles: function() { this.morph.each(s) }, onResize: function(t) { clearTimeout(this.resizeTimer), this.morph.each(O), this.resizeTimer = setTimeout(this.resize.bind(this), 250) }, resize: function() { this.morph.each(s) }, layerAction: function(t, e) { var i = e.layer.data("bubbleaddon"); if (!i) { if (!e.layer.hasClass("tp-bubblemorph")) return;
                s.call(e.layer) } if (i = e.layer.data("bubbleaddon")) switch (i.screen && i.screen.width && i.screen.height || (s.call(e.layer), i = e.layer.data("bubbleaddon")), e.eventtype) {
                case "enterstage":
                    k(i, e.layer); break;
                case "leftstage":
                    ! function(t, e) { t.pause = !0, e.data("bubblesplaying", !1) }(i, e.layer) } }, checkRemoved: function() { return (!this.slider || !document.body.contains(this.slider[0])) && (this.destroy(), !0) }, destroy: function() { for (var t in this.slider.find(".tp-bubblemorph").each(function() { var t = A(this);
                    t.data("bubbleaddon").pause = !0, t.removeData("bubbleaddon bubbleObj") }), this) this.hasOwnProperty(t) && delete this[t] } } }();